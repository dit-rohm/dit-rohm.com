---
layout: article_layout
title: アセンブリーでHello, World!
date: 2015-06-02 00:00 JST
author: ともくん
description: Intel Syntaxのアセンブリー言語でHello, Worldを書いてみます。
tags:
---
こんにちは。 DITメンターのともくんです。  
プログラミングの学習を始めてほとんどの人が始めに作るであろうプログラムは、標準出力に`"Hello, World!"`と表示するものでしょう。C言語なら```printf("Hello, World!")```などといった様子でしょう。関数を呼び出すとOSが標準出力に文字列が表示されるのは便利なこのですが、その舞台裏も気になるところだと思います。今日は、OSに頼らずに画面に文字を表示するようなプログラムを取り上げたいと思います。  
今回は、Intel SyntaxのアセンブリーをNASMでアセンブルして使います。コードは以下のようになります。`;`より右はコメントであり、動作の解説を加えています。 

```nasm
;hello.asm

bits 16        ;16ビットのコードであることを示す。Real Modeで動きます
org 0x7c00     ;アドレスの基準が0x7c00になるようにする

start:
jmp loader     ;printのルーチンを飛ばし、実行をloaderにジャンプさせる

print:
lodsb          ;文字列の次の文字を読み出し、alレジスタに格納する
or al, al      ;もしその文字がNULLなら、終了へジャンプする
jz done
mov ah, 0eh    ;int 10hを文字の書き出しをするモードする
int 10h        ;BIOSの割込み処理で、文字を書き出す
jmp print      ;上に戻って繰り返す
done:
ret

loader:
xor ax, ax     ;まず、この3行でセグメントの開始地点を0にする
mov ds, ax     
mov es, ax     

mov si, string ;下の文字列のあるアドレスをsiレジスタに入れる
call print     ;画面に表示するルーチンの呼び出し
cli
hlt

string db "Hello, World!", 0

times 510 - ($ - $$) db 0
dw 0xAA55      ;上の行と組み合わせて、ブートセクタであることを示している
```  

上のコードは16 bit Real Modeで動くので、画面への文字表示はBIOSの割込み処理である`int 10h`を使っています。32 bit Protected Modeにプロセッサのモードを変えるとBIOSの割込み処理すら使えなくなるのでメモリに直接書き込む必要が出てくるのですが、それは今日は扱いません。  
また、`lodbs`はsiレジスタがさす文字列の文字を1文字ずつ順にahレジスタに読み込んでいく命令です。これを使っているため、ループのカウンタとなるレジスタがありません。  

また、最後の部分は、510バイト目からの2バイトに0xAA55(16進数)を入れることで、これがブートセクタであることを示しています。ブートセクタとは、BIOSがコンピューターの起動の際に一番最初にメモリに読み込んで実行する512バイトの領域のことです。普通ならここにファイルシステムの情報とOSのカーネルを呼び出すコードが書かれていますが、今日は`"Hello, World"`と表示するプログラムが置かれています。  

これを、NASMでアセンブルします。NASMはIntel Syntaxのアセンブリーのためのアセンブラーです。上のコードを実行してみたい方は各自入手してください。(2-clause BSD Licenseで配布されているオープンソースソフトウェアです。)  

`nasm -f bin -o hello.bin hello.asm`  

アセンブルをするとバイナリファイルが出てくるので、これを起動ディスクとして仮想マシンで実行してみてください。また、実際のハードウェアで動かした場合のハードウェアの破損に対する責任は負いかねます。  
実行結果は以下のようになります。  

![実行結果](./2015-06-02/qemu.png "実行結果")

いかがでしょうか。文字をパソコンの画面に表示だけでも実は奥が深いものです。
